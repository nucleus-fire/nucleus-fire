use sqlx::{
    sqlite::SqliteRow,
    Row, SqlitePool, FromRow,
    database::HasArguments,
    query::Query,
    Sqlite,
    Encode,
    Type,
};
use std::fmt::Write;

/// A modern, fluent query builder for Nucleus.
/// 
/// # Example
/// ```rust
/// use nucleus_std::photon::query;
/// 
/// let users: Vec<User> = query("users")
///     .r#where("role", "admin")
///     .limit(10)
///     .all()
///     .await?;
/// ```
pub struct Builder<'a> {
    table: &'a str,
    select: Vec<String>,
    wheres: Vec<WhereClause>,
    joins: Vec<JoinClause>,
    order_by: Option<(String, String)>,
    limit: Option<i64>,
    offset: Option<i64>,
    
    // Mutation fields
    operation: Operation,
    values: Vec<(String, QueryValue)>, // For INSERT/UPDATE
    
    pool: Option<&'a SqlitePool>,
}

enum Operation {
    Select,
    Insert,
    Update,
    Delete,
}

// ... WhereClause, JoinClause, etc ...

impl<'a> Builder<'a> {
    pub fn new(table: &'a str) -> Self {
        Self {
            table,
            select: vec!["*".to_string()],
            wheres: vec![],
            joins: vec![],
            order_by: None,
            limit: None,
            offset: None,
            operation: Operation::Select,
            values: vec![],
            pool: None,
        }
    }

    // ... existing select/where methods ...

    /// Switch to INSERT mode
    pub fn insert(mut self) -> Self {
        self.operation = Operation::Insert;
        self
    }
    
    /// Switch to UPDATE mode
    pub fn update(mut self) -> Self {
        self.operation = Operation::Update;
        self
    }
    
    /// Switch to DELETE mode
    pub fn delete(mut self) -> Self {
        self.operation = Operation::Delete;
        self
    }
    
    /// Add a value for INSERT/UPDATE
    pub fn value<V>(mut self, column: &str, value: V) -> Self 
    where QueryValue: From<V>
    {
        self.values.push((column.to_string(), QueryValue::From(value)));
        self
    }
    
    // ... existing bind method ...

    /// Set the columns to select
    pub fn select(mut self, columns: &[&str]) -> Self {
        self.select = columns.iter().map(|s| s.to_string()).collect();
        self
    }

    /// Add a WHERE clause
    /// Usage: .where("id", 1) or .where("age", ">", 18)
    pub fn r#where<V>(mut self, column: &str, value: V) -> Self 
    where QueryValue: From<V>
    {
        self.wheres.push(WhereClause {
            column: column.to_string(),
            operator: "=".to_string(),
            value: QueryValue::From(value),
        });
        self
    }
    
    /// Add a WHERE clause with operator
    pub fn where_op<V>(mut self, column: &str, op: &str, value: V) -> Self 
    where QueryValue: From<V>
    {
        self.wheres.push(WhereClause {
            column: column.to_string(),
            operator: op.to_string(),
            value: QueryValue::From(value),
        });
        self
    }

    /// Add an INNER JOIN
    pub fn join(mut self, table: &str, on_left: &str, on_right: &str) -> Self {
        self.joins.push(JoinClause {
            table: table.to_string(),
            on_left: on_left.to_string(),
            on_right: on_right.to_string(),
            join_type: "INNER".to_string(),
        });
        self
    }

    /// Order results
    pub fn order_by(mut self, column: &str, direction: &str) -> Self {
        self.order_by = Some((column.to_string(), direction.to_string()));
        self
    }

    /// Add LIMIT
    pub fn limit(mut self, limit: i64) -> Self {
        self.limit = Some(limit);
        self
    }

    /// Bind to a connection pool
    pub fn bind(mut self, pool: &'a SqlitePool) -> Self {
        self.pool = Some(pool);
        self
    }

    /// Compile to SQL and execution
    pub fn to_sql(&self) -> (String, Vec<&QueryValue>) {
        let mut bindings = vec![];
        let mut sql = String::new();

        match self.operation {
            Operation::Select => {
                sql = format!("SELECT {} FROM {}", self.select.join(", "), self.table);
                
                for join in &self.joins {
                    write!(sql, " {} JOIN {} ON {} = {}", join.join_type, join.table, join.on_left, join.on_right).unwrap();
                }

                if !self.wheres.is_empty() {
                    sql.push_str(" WHERE ");
                    for (i, w) in self.wheres.iter().enumerate() {
                        if i > 0 { sql.push_str(" AND "); }
                        write!(sql, "{} {} ?", w.column, w.operator).unwrap();
                        bindings.push(&w.value);
                    }
                }

                if let Some((col, dir)) = &self.order_by {
                    write!(sql, " ORDER BY {} {}", col, dir).unwrap();
                }

                if let Some(limit) = self.limit {
                    write!(sql, " LIMIT {}", limit).unwrap();
                }
                
                if let Some(offset) = self.offset {
                    write!(sql, " OFFSET {}", offset).unwrap();
                }
            },
            Operation::Insert => {
                let cols: Vec<String> = self.values.iter().map(|(c, _)| c.clone()).collect();
                let placeholders: Vec<String> = self.values.iter().map(|_| "?".to_string()).collect();
                
                write!(sql, "INSERT INTO {} ({}) VALUES ({})", 
                    self.table, 
                    cols.join(", "), 
                    placeholders.join(", ")
                ).unwrap();
                
                for (_, v) in &self.values {
                    bindings.push(v);
                }
            },
            Operation::Update => {
                write!(sql, "UPDATE {} SET ", self.table).unwrap();
                
                for (i, (col, val)) in self.values.iter().enumerate() {
                    if i > 0 { sql.push_str(", "); }
                    write!(sql, "{} = ?", col).unwrap();
                    bindings.push(val);
                }
                
                if !self.wheres.is_empty() {
                    sql.push_str(" WHERE ");
                    for (i, w) in self.wheres.iter().enumerate() {
                        if i > 0 { sql.push_str(" AND "); }
                        write!(sql, "{} {} ?", w.column, w.operator).unwrap();
                        bindings.push(&w.value);
                    }
                }
            },
            Operation::Delete => {
                write!(sql, "DELETE FROM {}", self.table).unwrap();
                
                if !self.wheres.is_empty() {
                    sql.push_str(" WHERE ");
                    for (i, w) in self.wheres.iter().enumerate() {
                        if i > 0 { sql.push_str(" AND "); }
                        write!(sql, "{} {} ?", w.column, w.operator).unwrap();
                        bindings.push(&w.value);
                    }
                }
            }
        }

        (sql, bindings)
    }

    /// Execute and try to return mapped rows
    pub async fn all<T>(self) -> Result<Vec<T>, sqlx::Error>
    where
        T: for<'r> FromRow<'r, SqliteRow> + Send + Unpin,
    {
        // Must use explicit pool or fail
         // In a real framework, we'd use a global pool if none provided, 
         // but here we expect the user to pass one or we error/panic for now.
         let (sql, values) = self.to_sql();
         
         // NOTE: Need to handle the pool reference. 
         // For now, assuming user binds it or we fetch global.
         // Let's assume global pool for advanced UX? 
         // For safety/purity, we'll error if no pool.
         let pool = self.pool.expect("Pool not bound. Use .bind(pool)");

         let mut query = sqlx::query_as::<_, T>(&sql);
         
         for val in values {
             query = match val {
                 QueryValue::Text(v) => query.bind(v),
                 QueryValue::Int(v) => query.bind(v),
                 QueryValue::Float(v) => query.bind(v),
                 QueryValue::Bool(v) => query.bind(v),
                 QueryValue::Null => query.bind(Option::<String>::None), // Generic null
             };
         }

         query.fetch_all(pool).await
    }
    
    pub async fn first<T>(self) -> Result<Option<T>, sqlx::Error>
    where
        T: for<'r> FromRow<'r, SqliteRow> + Send + Unpin,
    {
        let builder = self.limit(1);
        let results = builder.all::<T>().await?;
        Ok(results.into_iter().next())
    }
    
    /// Execute INSERT/UPDATE/DELETE
    pub async fn execute(self) -> Result<sqlx::sqlite::SqliteQueryResult, sqlx::Error> {
        let (sql, values) = self.to_sql();
        let pool = self.pool.expect("Pool not bound. Use .bind(pool)");

        let mut query = sqlx::query(&sql);
        
        for val in values {
            query = match val {
                QueryValue::Text(v) => query.bind(v),
                QueryValue::Int(v) => query.bind(v),
                QueryValue::Float(v) => query.bind(v),
                QueryValue::Bool(v) => query.bind(v),
                QueryValue::Null => query.bind(Option::<String>::None),
            };
        }

        query.execute(pool).await
    }
}

// Converters for QueryValue
impl From<&str> for QueryValue {
    fn from(v: &str) -> Self { QueryValue::Text(v.to_string()) }
}
impl From<String> for QueryValue {
    fn from(v: String) -> Self { QueryValue::Text(v) }
}
impl From<i64> for QueryValue {
    fn from(v: i64) -> Self { QueryValue::Int(v) }
}
impl From<i32> for QueryValue {
    fn from(v: i32) -> Self { QueryValue::Int(v as i64) }
}
impl From<f64> for QueryValue {
    fn from(v: f64) -> Self { QueryValue::Float(v) }
}
impl From<bool> for QueryValue {
    fn from(v: bool) -> Self { QueryValue::Bool(v) }
}

/// Entry point
pub fn query(table: &str) -> Builder {
    Builder::new(table)
}
